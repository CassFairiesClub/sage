
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async initialize() : Promise<null> {
    return await TAURI_INVOKE("initialize");
},
async login(req: Login) : Promise<LoginResponse> {
    return await TAURI_INVOKE("login", { req });
},
async logout(req: Logout) : Promise<LogoutResponse> {
    return await TAURI_INVOKE("logout", { req });
},
async resync(req: Resync) : Promise<ResyncResponse> {
    return await TAURI_INVOKE("resync", { req });
},
async generateMnemonic(req: GenerateMnemonic) : Promise<GenerateMnemonicResponse> {
    return await TAURI_INVOKE("generate_mnemonic", { req });
},
async importKey(req: ImportKey) : Promise<ImportKeyResponse> {
    return await TAURI_INVOKE("import_key", { req });
},
async deleteKey(req: DeleteKey) : Promise<DeleteKeyResponse> {
    return await TAURI_INVOKE("delete_key", { req });
},
async deleteDatabase(req: DeleteDatabase) : Promise<DeleteDatabaseResponse> {
    return await TAURI_INVOKE("delete_database", { req });
},
async renameKey(req: RenameKey) : Promise<RenameKeyResponse> {
    return await TAURI_INVOKE("rename_key", { req });
},
async getKeys(req: GetKeys) : Promise<GetKeysResponse> {
    return await TAURI_INVOKE("get_keys", { req });
},
async setWalletEmoji(req: SetWalletEmoji) : Promise<SetWalletEmojiResponse> {
    return await TAURI_INVOKE("set_wallet_emoji", { req });
},
async getKey(req: GetKey) : Promise<GetKeyResponse> {
    return await TAURI_INVOKE("get_key", { req });
},
async getSecretKey(req: GetSecretKey) : Promise<GetSecretKeyResponse> {
    return await TAURI_INVOKE("get_secret_key", { req });
},
async sendXch(req: SendXch) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("send_xch", { req });
},
async bulkSendXch(req: BulkSendXch) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("bulk_send_xch", { req });
},
async combine(req: Combine) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("combine", { req });
},
async split(req: Split) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("split", { req });
},
async autoCombineXch(req: AutoCombineXch) : Promise<AutoCombineXchResponse> {
    return await TAURI_INVOKE("auto_combine_xch", { req });
},
async sendCat(req: SendCat) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("send_cat", { req });
},
async bulkSendCat(req: BulkSendCat) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("bulk_send_cat", { req });
},
async autoCombineCat(req: AutoCombineCat) : Promise<AutoCombineCatResponse> {
    return await TAURI_INVOKE("auto_combine_cat", { req });
},
async issueCat(req: IssueCat) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("issue_cat", { req });
},
async createDid(req: CreateDid) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("create_did", { req });
},
async bulkMintNfts(req: BulkMintNfts) : Promise<BulkMintNftsResponse> {
    return await TAURI_INVOKE("bulk_mint_nfts", { req });
},
async transferNfts(req: TransferNfts) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("transfer_nfts", { req });
},
async transferDids(req: TransferDids) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("transfer_dids", { req });
},
async normalizeDids(req: NormalizeDids) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("normalize_dids", { req });
},
async mintOption(req: MintOption) : Promise<MintOptionResponse> {
    return await TAURI_INVOKE("mint_option", { req });
},
async transferOptions(req: TransferOptions) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("transfer_options", { req });
},
async exerciseOptions(req: ExerciseOptions) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("exercise_options", { req });
},
async addNftUri(req: AddNftUri) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("add_nft_uri", { req });
},
async assignNftsToDid(req: AssignNftsToDid) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("assign_nfts_to_did", { req });
},
async signCoinSpends(req: SignCoinSpends) : Promise<SignCoinSpendsResponse> {
    return await TAURI_INVOKE("sign_coin_spends", { req });
},
async viewCoinSpends(req: ViewCoinSpends) : Promise<ViewCoinSpendsResponse> {
    return await TAURI_INVOKE("view_coin_spends", { req });
},
async submitTransaction(req: SubmitTransaction) : Promise<SubmitTransactionResponse> {
    return await TAURI_INVOKE("submit_transaction", { req });
},
async getSyncStatus(req: GetSyncStatus) : Promise<GetSyncStatusResponse> {
    return await TAURI_INVOKE("get_sync_status", { req });
},
async getVersion(req: GetVersion) : Promise<GetVersionResponse> {
    return await TAURI_INVOKE("get_version", { req });
},
async getDatabaseStats(req: GetDatabaseStats) : Promise<GetDatabaseStatsResponse> {
    return await TAURI_INVOKE("get_database_stats", { req });
},
async performDatabaseMaintenance(req: PerformDatabaseMaintenance) : Promise<PerformDatabaseMaintenanceResponse> {
    return await TAURI_INVOKE("perform_database_maintenance", { req });
},
async checkAddress(req: CheckAddress) : Promise<CheckAddressResponse> {
    return await TAURI_INVOKE("check_address", { req });
},
async getDerivations(req: GetDerivations) : Promise<GetDerivationsResponse> {
    return await TAURI_INVOKE("get_derivations", { req });
},
async getAreCoinsSpendable(req: GetAreCoinsSpendable) : Promise<GetAreCoinsSpendableResponse> {
    return await TAURI_INVOKE("get_are_coins_spendable", { req });
},
async getSpendableCoinCount(req: GetSpendableCoinCount) : Promise<GetSpendableCoinCountResponse> {
    return await TAURI_INVOKE("get_spendable_coin_count", { req });
},
async getCoinsByIds(req: GetCoinsByIds) : Promise<GetCoinsByIdsResponse> {
    return await TAURI_INVOKE("get_coins_by_ids", { req });
},
async getCoins(req: GetCoins) : Promise<GetCoinsResponse> {
    return await TAURI_INVOKE("get_coins", { req });
},
async getCats(req: GetCats) : Promise<GetCatsResponse> {
    return await TAURI_INVOKE("get_cats", { req });
},
async getAllCats(req: GetAllCats) : Promise<GetAllCatsResponse> {
    return await TAURI_INVOKE("get_all_cats", { req });
},
async getToken(req: GetToken) : Promise<GetTokenResponse> {
    return await TAURI_INVOKE("get_token", { req });
},
async getDids(req: GetDids) : Promise<GetDidsResponse> {
    return await TAURI_INVOKE("get_dids", { req });
},
async getMinterDidIds(req: GetMinterDidIds) : Promise<GetMinterDidIdsResponse> {
    return await TAURI_INVOKE("get_minter_did_ids", { req });
},
async getOptions(req: GetOptions) : Promise<GetOptionsResponse> {
    return await TAURI_INVOKE("get_options", { req });
},
async getOption(req: GetOption) : Promise<GetOptionResponse> {
    return await TAURI_INVOKE("get_option", { req });
},
async getNftCollections(req: GetNftCollections) : Promise<GetNftCollectionsResponse> {
    return await TAURI_INVOKE("get_nft_collections", { req });
},
async getNftCollection(req: GetNftCollection) : Promise<GetNftCollectionResponse> {
    return await TAURI_INVOKE("get_nft_collection", { req });
},
async getNfts(req: GetNfts) : Promise<GetNftsResponse> {
    return await TAURI_INVOKE("get_nfts", { req });
},
async getNft(req: GetNft) : Promise<GetNftResponse> {
    return await TAURI_INVOKE("get_nft", { req });
},
async getNftData(req: GetNftData) : Promise<GetNftDataResponse> {
    return await TAURI_INVOKE("get_nft_data", { req });
},
async getNftIcon(req: GetNftIcon) : Promise<GetNftIconResponse> {
    return await TAURI_INVOKE("get_nft_icon", { req });
},
async getNftThumbnail(req: GetNftThumbnail) : Promise<GetNftThumbnailResponse> {
    return await TAURI_INVOKE("get_nft_thumbnail", { req });
},
async getPendingTransactions(req: GetPendingTransactions) : Promise<GetPendingTransactionsResponse> {
    return await TAURI_INVOKE("get_pending_transactions", { req });
},
async getTransaction(req: GetTransaction) : Promise<GetTransactionResponse> {
    return await TAURI_INVOKE("get_transaction", { req });
},
async getTransactions(req: GetTransactions) : Promise<GetTransactionsResponse> {
    return await TAURI_INVOKE("get_transactions", { req });
},
async validateAddress(address: string) : Promise<boolean> {
    return await TAURI_INVOKE("validate_address", { address });
},
async makeOffer(req: MakeOffer) : Promise<MakeOfferResponse> {
    return await TAURI_INVOKE("make_offer", { req });
},
async takeOffer(req: TakeOffer) : Promise<TakeOfferResponse> {
    return await TAURI_INVOKE("take_offer", { req });
},
async combineOffers(req: CombineOffers) : Promise<CombineOffersResponse> {
    return await TAURI_INVOKE("combine_offers", { req });
},
async viewOffer(req: ViewOffer) : Promise<ViewOfferResponse> {
    return await TAURI_INVOKE("view_offer", { req });
},
async importOffer(req: ImportOffer) : Promise<ImportOfferResponse> {
    return await TAURI_INVOKE("import_offer", { req });
},
async getOffers(req: GetOffers) : Promise<GetOffersResponse> {
    return await TAURI_INVOKE("get_offers", { req });
},
async getOffersForAsset(req: GetOffersForAsset) : Promise<GetOffersForAssetResponse> {
    return await TAURI_INVOKE("get_offers_for_asset", { req });
},
async getOffer(req: GetOffer) : Promise<GetOfferResponse> {
    return await TAURI_INVOKE("get_offer", { req });
},
async deleteOffer(req: DeleteOffer) : Promise<DeleteOfferResponse> {
    return await TAURI_INVOKE("delete_offer", { req });
},
async cancelOffer(req: CancelOffer) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("cancel_offer", { req });
},
async cancelOffers(req: CancelOffers) : Promise<TransactionResponse> {
    return await TAURI_INVOKE("cancel_offers", { req });
},
async networkConfig() : Promise<NetworkConfig> {
    return await TAURI_INVOKE("network_config");
},
async setDiscoverPeers(req: SetDiscoverPeers) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("set_discover_peers", { req });
},
async setTargetPeers(req: SetTargetPeers) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("set_target_peers", { req });
},
async setNetwork(req: SetNetwork) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("set_network", { req });
},
async setNetworkOverride(req: SetNetworkOverride) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("set_network_override", { req });
},
async walletConfig(fingerprint: number) : Promise<Wallet | null> {
    return await TAURI_INVOKE("wallet_config", { fingerprint });
},
async defaultWalletConfig() : Promise<WalletDefaults> {
    return await TAURI_INVOKE("default_wallet_config");
},
async getNetworks(req: GetNetworks) : Promise<NetworkList> {
    return await TAURI_INVOKE("get_networks", { req });
},
async getNetwork(req: GetNetwork) : Promise<GetNetworkResponse> {
    return await TAURI_INVOKE("get_network", { req });
},
async setDeltaSync(req: SetDeltaSync) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("set_delta_sync", { req });
},
async setDeltaSyncOverride(req: SetDeltaSyncOverride) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("set_delta_sync_override", { req });
},
async setChangeAddress(req: SetChangeAddress) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("set_change_address", { req });
},
async updateCat(req: UpdateCat) : Promise<UpdateCatResponse> {
    return await TAURI_INVOKE("update_cat", { req });
},
async resyncCat(req: ResyncCat) : Promise<ResyncCatResponse> {
    return await TAURI_INVOKE("resync_cat", { req });
},
async updateDid(req: UpdateDid) : Promise<UpdateDidResponse> {
    return await TAURI_INVOKE("update_did", { req });
},
async updateOption(req: UpdateOption) : Promise<UpdateOptionResponse> {
    return await TAURI_INVOKE("update_option", { req });
},
async updateNft(req: UpdateNft) : Promise<UpdateNftResponse> {
    return await TAURI_INVOKE("update_nft", { req });
},
async updateNftCollection(req: UpdateNftCollection) : Promise<UpdateNftCollectionResponse> {
    return await TAURI_INVOKE("update_nft_collection", { req });
},
async redownloadNft(req: RedownloadNft) : Promise<RedownloadNftResponse> {
    return await TAURI_INVOKE("redownload_nft", { req });
},
async increaseDerivationIndex(req: IncreaseDerivationIndex) : Promise<IncreaseDerivationIndexResponse> {
    return await TAURI_INVOKE("increase_derivation_index", { req });
},
async getPeers(req: GetPeers) : Promise<GetPeersResponse> {
    return await TAURI_INVOKE("get_peers", { req });
},
async getUserTheme(req: GetUserTheme) : Promise<GetUserThemeResponse> {
    return await TAURI_INVOKE("get_user_theme", { req });
},
async getUserThemes(req: GetUserThemes) : Promise<GetUserThemesResponse> {
    return await TAURI_INVOKE("get_user_themes", { req });
},
async saveUserTheme(req: SaveUserTheme) : Promise<SaveUserThemeResponse> {
    return await TAURI_INVOKE("save_user_theme", { req });
},
async deleteUserTheme(req: DeleteUserTheme) : Promise<DeleteUserThemeResponse> {
    return await TAURI_INVOKE("delete_user_theme", { req });
},
async addPeer(req: AddPeer) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("add_peer", { req });
},
async removePeer(req: RemovePeer) : Promise<EmptyResponse> {
    return await TAURI_INVOKE("remove_peer", { req });
},
async filterUnlockedCoins(req: FilterUnlockedCoins) : Promise<FilterUnlockedCoinsResponse> {
    return await TAURI_INVOKE("filter_unlocked_coins", { req });
},
async getAssetCoins(req: GetAssetCoins) : Promise<SpendableCoin[]> {
    return await TAURI_INVOKE("get_asset_coins", { req });
},
async signMessageWithPublicKey(req: SignMessageWithPublicKey) : Promise<SignMessageWithPublicKeyResponse> {
    return await TAURI_INVOKE("sign_message_with_public_key", { req });
},
async signMessageByAddress(req: SignMessageByAddress) : Promise<SignMessageByAddressResponse> {
    return await TAURI_INVOKE("sign_message_by_address", { req });
},
async sendTransactionImmediately(req: SendTransactionImmediately) : Promise<SendTransactionImmediatelyResponse> {
    return await TAURI_INVOKE("send_transaction_immediately", { req });
},
async isRpcRunning() : Promise<boolean> {
    return await TAURI_INVOKE("is_rpc_running");
},
async startRpcServer() : Promise<null> {
    return await TAURI_INVOKE("start_rpc_server");
},
async stopRpcServer() : Promise<null> {
    return await TAURI_INVOKE("stop_rpc_server");
},
async getRpcRunOnStartup() : Promise<boolean> {
    return await TAURI_INVOKE("get_rpc_run_on_startup");
},
async setRpcRunOnStartup(runOnStartup: boolean) : Promise<null> {
    return await TAURI_INVOKE("set_rpc_run_on_startup", { runOnStartup });
},
async switchWallet() : Promise<null> {
    return await TAURI_INVOKE("switch_wallet");
},
async moveKey(fingerprint: number, index: number) : Promise<null> {
    return await TAURI_INVOKE("move_key", { fingerprint, index });
},
async downloadCniOffercode(code: string) : Promise<string> {
    return await TAURI_INVOKE("download_cni_offercode", { code });
},
async getLogs() : Promise<LogFile[]> {
    return await TAURI_INVOKE("get_logs");
},
async isAssetOwned(req: IsAssetOwned) : Promise<IsAssetOwnedResponse> {
    return await TAURI_INVOKE("is_asset_owned", { req });
}
}

/** user-defined events **/


export const events = __makeEvents__<{
syncEvent: SyncEvent
}>({
syncEvent: "sync-event"
})

/** user-defined constants **/



/** user-defined types **/

/**
 * Add a URI to an NFT
 */
export type AddNftUri = { 
/**
 * NFT ID
 */
nft_id: string; 
/**
 * URI to add
 */
uri: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Type of URI
 */
kind: NftUriKind; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Add a new peer to connect to
 */
export type AddPeer = { 
/**
 * IP address or hostname with port
 */
ip: string }
export type AddressKind = "own" | "burn" | "launcher" | "offer" | "external" | "unknown"
export type Amount = string | number
export type Asset = { asset_id: string | null; name: string | null; ticker: string | null; precision: number; icon_url: string | null; description: string | null; is_sensitive_content: boolean; is_visible: boolean; revocation_address: string | null; kind: AssetKind }
/**
 * Type of asset coin
 */
export type AssetCoinType = "cat" | "did" | "nft"
export type AssetKind = "token" | "nft" | "did" | "option"
/**
 * Assign NFTs to a DID
 */
export type AssignNftsToDid = { 
/**
 * NFT IDs to assign
 */
nft_ids: string[]; 
/**
 * DID ID (null to unassign)
 */
did_id: string | null; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Automatically combine CAT coins
 */
export type AutoCombineCat = { 
/**
 * Asset ID of the CAT
 */
asset_id: string; 
/**
 * Maximum number of coins to combine
 */
max_coins: number; 
/**
 * Optional maximum amount per coin
 */
max_coin_amount: Amount | null; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Response for auto-combine CAT
 */
export type AutoCombineCatResponse = { 
/**
 * Combined coin IDs
 */
coin_ids: string[]; 
/**
 * Transaction summary
 */
summary: TransactionSummary; 
/**
 * Coin spends in the transaction
 */
coin_spends: CoinSpendJson[] }
/**
 * Automatically combine XCH coins
 */
export type AutoCombineXch = { 
/**
 * Maximum number of coins to combine
 */
max_coins: number; 
/**
 * Optional maximum amount per coin
 */
max_coin_amount: Amount | null; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Response for auto-combine XCH
 */
export type AutoCombineXchResponse = { 
/**
 * Combined coin IDs
 */
coin_ids: string[]; 
/**
 * Transaction summary
 */
summary: TransactionSummary; 
/**
 * Coin spends in the transaction
 */
coin_spends: CoinSpendJson[] }
/**
 * Mint multiple NFTs in one transaction
 */
export type BulkMintNfts = { 
/**
 * List of NFTs to mint
 */
mints: NftMint[]; 
/**
 * DID ID for the NFT collection
 */
did_id: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Response for bulk NFT minting
 */
export type BulkMintNftsResponse = { 
/**
 * List of minted NFT IDs
 */
nft_ids: string[]; 
/**
 * Transaction summary
 */
summary: TransactionSummary; 
/**
 * Coin spends in the transaction
 */
coin_spends: CoinSpendJson[] }
/**
 * Send CAT tokens to multiple addresses
 */
export type BulkSendCat = { 
/**
 * Asset ID of the CAT
 */
asset_id: string; 
/**
 * List of recipient addresses
 */
addresses: string[]; 
/**
 * Amount to send to each address
 */
amount: Amount; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to include the CAT hint
 */
include_hint?: boolean; 
/**
 * Optional memos
 */
memos?: string[]; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Send XCH to multiple addresses
 */
export type BulkSendXch = { 
/**
 * List of recipient addresses
 */
addresses: string[]; 
/**
 * Amount to send to each address
 */
amount: Amount; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Optional memos
 */
memos?: string[]; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Cancel an offer on-chain
 */
export type CancelOffer = { 
/**
 * Offer ID to cancel
 */
offer_id: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Cancel multiple offers
 */
export type CancelOffers = { 
/**
 * Offer IDs to cancel
 */
offer_ids: string[]; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Validate and check an address
 */
export type CheckAddress = { 
/**
 * Address to validate
 */
address: string }
/**
 * Response with address validation result
 */
export type CheckAddressResponse = { 
/**
 * Whether the address is valid and belongs to this wallet
 */
valid: boolean }
/**
 * Coin structure
 */
export type Coin = { 
/**
 * Parent coin info
 */
parent_coin_info: string; 
/**
 * Puzzle hash
 */
puzzle_hash: string; 
/**
 * Amount in mojos
 */
amount: number }
export type CoinFilterMode = "all" | "selectable" | "owned" | "spent" | "clawback"
export type CoinJson = { parent_coin_info: string; puzzle_hash: string; amount: Amount }
export type CoinRecord = { coin_id: string; address: string; amount: Amount; transaction_id: string | null; offer_id: string | null; clawback_timestamp: number | null; created_height: number | null; spent_height: number | null; spent_timestamp: number | null; created_timestamp: number | null }
export type CoinSortMode = "coin_id" | "amount" | "created_height" | "spent_height" | "clawback_timestamp"
/**
 * Coin spend structure
 */
export type CoinSpend = { 
/**
 * Coin being spent
 */
coin: Coin; 
/**
 * Puzzle reveal
 */
puzzle_reveal: string; 
/**
 * Solution
 */
solution: string }
export type CoinSpendJson = { coin: CoinJson; puzzle_reveal: string; solution: string }
/**
 * Combine multiple coins into one
 */
export type Combine = { 
/**
 * Coin IDs to combine
 */
coin_ids: string[]; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Combine multiple offers
 */
export type CombineOffers = { 
/**
 * Offer strings to combine
 */
offers: string[] }
/**
 * Response with combined offer
 */
export type CombineOffersResponse = { 
/**
 * Combined offer string
 */
offer: string }
/**
 * Create a new DID
 */
export type CreateDid = { 
/**
 * DID name
 */
name: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Delete a wallet database
 */
export type DeleteDatabase = { 
/**
 * Wallet fingerprint
 */
fingerprint: number; 
/**
 * Network name
 */
network: string }
/**
 * Response for database deletion
 */
export type DeleteDatabaseResponse = Record<string, never>
/**
 * Delete a wallet key
 */
export type DeleteKey = { 
/**
 * Wallet fingerprint to delete
 */
fingerprint: number }
/**
 * Response for key deletion
 */
export type DeleteKeyResponse = Record<string, never>
/**
 * Delete an offer
 */
export type DeleteOffer = { 
/**
 * Offer ID to delete
 */
offer_id: string }
/**
 * Response for offer deletion
 */
export type DeleteOfferResponse = Record<string, never>
/**
 * Delete a theme NFT from the wallet
 */
export type DeleteUserTheme = { 
/**
 * NFT ID of the theme
 */
nft_id: string }
export type DeleteUserThemeResponse = Record<string, never>
export type DerivationRecord = { index: number; public_key: string; address: string }
export type DidRecord = { launcher_id: string; name: string | null; visible: boolean; coin_id: string; address: string; amount: Amount; recovery_hash: string | null; created_height: number | null }
export type EmptyResponse = Record<string, never>
export type Error = { kind: ErrorKind; reason: string }
export type ErrorKind = "wallet" | "api" | "not_found" | "unauthorized" | "internal" | "database_migration" | "nfc"
/**
 * Exercise options
 */
export type ExerciseOptions = { 
/**
 * Option IDs to exercise
 */
option_ids: string[]; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Filter unlocked coins from a list
 */
export type FilterUnlockedCoins = { 
/**
 * Coin IDs to filter
 */
coin_ids: string[] }
/**
 * Response with unlocked coin IDs
 */
export type FilterUnlockedCoinsResponse = { 
/**
 * List of unlocked coin IDs
 */
coin_ids: string[] }
/**
 * Generate a new mnemonic phrase for wallet creation
 */
export type GenerateMnemonic = { 
/**
 * Whether to generate a 24-word mnemonic instead of 12-word
 */
use_24_words: boolean }
/**
 * Response containing the generated mnemonic phrase
 */
export type GenerateMnemonicResponse = { 
/**
 * The generated BIP-39 mnemonic phrase
 */
mnemonic: string }
/**
 * Get all known CAT tokens
 */
export type GetAllCats = Record<string, never>
/**
 * Response with all known CAT tokens
 */
export type GetAllCatsResponse = { 
/**
 * List of all CAT tokens
 */
cats: TokenRecord[] }
/**
 * Check if specific coins are spendable
 */
export type GetAreCoinsSpendable = { 
/**
 * List of coin IDs to check
 */
coin_ids: string[] }
/**
 * Response with spendability status
 */
export type GetAreCoinsSpendableResponse = { 
/**
 * Whether all coins are spendable
 */
spendable: boolean }
/**
 * Get spendable coins for an asset
 */
export type GetAssetCoins = { 
/**
 * Type of asset coin
 */
type?: AssetCoinType | null; 
/**
 * Asset ID to filter by
 */
assetId?: string | null; 
/**
 * Whether to include locked coins
 */
includedLocked?: boolean | null; 
/**
 * Pagination offset
 */
offset?: number | null; 
/**
 * Number of results to return
 */
limit?: number | null }
/**
 * Get CAT tokens in wallet
 */
export type GetCats = Record<string, never>
/**
 * Response with CAT tokens
 */
export type GetCatsResponse = { cats: TokenRecord[] }
/**
 * List coins with filtering and pagination
 */
export type GetCoins = { 
/**
 * Optional asset ID to filter by
 */
asset_id?: string | null; 
/**
 * Starting offset for pagination
 */
offset: number; 
/**
 * Number of coins to return
 */
limit: number; 
/**
 * Sort mode
 */
sort_mode?: CoinSortMode; 
/**
 * Filter mode
 */
filter_mode?: CoinFilterMode; 
/**
 * Sort in ascending order
 */
ascending?: boolean }
/**
 * Retrieve specific coins by their IDs
 */
export type GetCoinsByIds = { 
/**
 * List of coin IDs to retrieve
 */
coin_ids: string[] }
/**
 * Response with requested coins
 */
export type GetCoinsByIdsResponse = { 
/**
 * List of coins matching the requested IDs
 */
coins: CoinRecord[] }
/**
 * Response with coin list
 */
export type GetCoinsResponse = { 
/**
 * List of coins
 */
coins: CoinRecord[]; 
/**
 * Total number of coins available
 */
total: number }
/**
 * Retrieve database statistics
 */
export type GetDatabaseStats = Record<string, never>
/**
 * Response with database statistics
 */
export type GetDatabaseStatsResponse = { 
/**
 * Total pages in database
 */
total_pages: number; 
/**
 * Number of free pages
 */
free_pages: number; 
/**
 * Percentage of free space
 */
free_percentage: number; 
/**
 * Size of each page in bytes
 */
page_size: number; 
/**
 * Total database size in bytes
 */
database_size_bytes: number; 
/**
 * Free space in bytes
 */
free_space_bytes: number; 
/**
 * Number of WAL pages
 */
wal_pages: number }
/**
 * Get address derivation information
 */
export type GetDerivations = { 
/**
 * Whether to retrieve hardened derivations
 */
hardened?: boolean; 
/**
 * Starting offset for pagination
 */
offset: number; 
/**
 * Number of derivations to return
 */
limit: number }
/**
 * Response with derivation records
 */
export type GetDerivationsResponse = { 
/**
 * List of address derivations
 */
derivations: DerivationRecord[]; 
/**
 * Total number of derivations available
 */
total: number }
/**
 * List all DIDs in the wallet
 */
export type GetDids = Record<string, never>
/**
 * Response with DID list
 */
export type GetDidsResponse = { 
/**
 * List of DIDs
 */
dids: DidRecord[] }
/**
 * Get a specific wallet key
 */
export type GetKey = { 
/**
 * Wallet fingerprint (uses currently logged in if null)
 */
fingerprint?: number | null }
/**
 * Response with key information
 */
export type GetKeyResponse = { 
/**
 * Key information if found
 */
key: KeyInfo | null }
/**
 * List all wallet keys
 */
export type GetKeys = Record<string, never>
/**
 * Response with all wallet keys
 */
export type GetKeysResponse = { 
/**
 * List of wallet keys
 */
keys: KeyInfo[] }
/**
 * Get minter DIDs with pagination
 */
export type GetMinterDidIds = { 
/**
 * Starting offset for pagination
 */
offset: number; 
/**
 * Number of DID IDs to return
 */
limit: number }
/**
 * Response with minter DID IDs
 */
export type GetMinterDidIdsResponse = { 
/**
 * List of minter DID IDs
 */
did_ids: string[]; 
/**
 * Total number of minter DIDs
 */
total: number }
/**
 * Get current network information
 */
export type GetNetwork = Record<string, never>
/**
 * Response containing current network information
 */
export type GetNetworkResponse = { 
/**
 * Current network configuration
 */
network: Network; 
/**
 * Network type classification
 */
kind: NetworkKind }
/**
 * List available networks
 */
export type GetNetworks = Record<string, never>
/**
 * Get a specific NFT
 */
export type GetNft = { 
/**
 * NFT coin ID
 */
nft_id: string }
/**
 * Get a specific NFT collection
 */
export type GetNftCollection = { 
/**
 * Collection ID (null for uncollected NFTs)
 */
collection_id: string | null }
/**
 * Response with NFT collection details
 */
export type GetNftCollectionResponse = { 
/**
 * Collection if found
 */
collection: NftCollectionRecord | null }
/**
 * List NFT collections
 */
export type GetNftCollections = { 
/**
 * Starting offset for pagination
 */
offset: number; 
/**
 * Number of collections to return
 */
limit: number; 
/**
 * Include hidden collections
 */
include_hidden: boolean }
/**
 * Response with NFT collections
 */
export type GetNftCollectionsResponse = { 
/**
 * List of NFT collections
 */
collections: NftCollectionRecord[]; 
/**
 * Total number of collections
 */
total: number }
/**
 * Get NFT data file
 */
export type GetNftData = { 
/**
 * NFT coin ID
 */
nft_id: string }
/**
 * Response with NFT data
 */
export type GetNftDataResponse = { 
/**
 * NFT data if available
 */
data: NftData | null }
/**
 * Get NFT icon image
 */
export type GetNftIcon = { 
/**
 * NFT coin ID
 */
nft_id: string }
/**
 * Response with NFT icon
 */
export type GetNftIconResponse = { 
/**
 * Base64-encoded icon image
 */
icon: string | null }
/**
 * Response with NFT details
 */
export type GetNftResponse = { 
/**
 * NFT if found
 */
nft: NftRecord | null }
/**
 * Get NFT thumbnail image
 */
export type GetNftThumbnail = { 
/**
 * NFT coin ID
 */
nft_id: string }
/**
 * Response with NFT thumbnail
 */
export type GetNftThumbnailResponse = { 
/**
 * Base64-encoded thumbnail image
 */
thumbnail: string | null }
/**
 * List NFTs with filtering
 */
export type GetNfts = { 
/**
 * Filter by collection ID
 */
collection_id?: string | null; 
/**
 * Filter by minter DID
 */
minter_did_id?: string | null; 
/**
 * Filter by owner DID
 */
owner_did_id?: string | null; 
/**
 * Filter by name search
 */
name?: string | null; 
/**
 * Starting offset for pagination
 */
offset: number; 
/**
 * Number of NFTs to return
 */
limit: number; 
/**
 * Sort mode
 */
sort_mode: NftSortMode; 
/**
 * Include hidden NFTs
 */
include_hidden: boolean }
/**
 * Response with NFTs list
 */
export type GetNftsResponse = { 
/**
 * List of NFTs
 */
nfts: NftRecord[]; 
/**
 * Total number of NFTs
 */
total: number }
/**
 * Get a specific offer
 */
export type GetOffer = { 
/**
 * Offer ID
 */
offer_id: string }
/**
 * Response with offer details
 */
export type GetOfferResponse = { 
/**
 * Offer details
 */
offer: OfferRecord }
/**
 * List all offers
 */
export type GetOffers = Record<string, never>
/**
 * Get offers for a specific asset
 */
export type GetOffersForAsset = { 
/**
 * Asset ID to filter by
 */
asset_id: string }
/**
 * Response with offers for asset
 */
export type GetOffersForAssetResponse = { 
/**
 * List of offers involving the asset
 */
offers: OfferRecord[] }
/**
 * Response with list of offers
 */
export type GetOffersResponse = { 
/**
 * List of offers
 */
offers: OfferRecord[] }
/**
 * Get a specific option
 */
export type GetOption = { 
/**
 * Option ID
 */
option_id: string }
/**
 * Response with option details
 */
export type GetOptionResponse = { 
/**
 * Option information if found
 */
option: OptionRecord | null }
/**
 * List options with filtering
 */
export type GetOptions = { 
/**
 * Starting offset for pagination
 */
offset: number; 
/**
 * Number of options to return
 */
limit: number; 
/**
 * Sort mode
 */
sort_mode?: OptionSortMode; 
/**
 * Sort in ascending order
 */
ascending?: boolean; 
/**
 * Optional search value
 */
find_value: string | null; 
/**
 * Include hidden options
 */
include_hidden?: boolean }
/**
 * Response with options list
 */
export type GetOptionsResponse = { 
/**
 * List of options
 */
options: OptionRecord[]; 
/**
 * Total number of options
 */
total: number }
/**
 * List all network peers
 */
export type GetPeers = Record<string, never>
/**
 * Response containing peer list
 */
export type GetPeersResponse = { 
/**
 * List of connected peers
 */
peers: PeerRecord[] }
/**
 * Get pending transactions
 */
export type GetPendingTransactions = Record<string, never>
/**
 * Response with pending transactions
 */
export type GetPendingTransactionsResponse = { 
/**
 * List of pending transactions
 */
transactions: PendingTransactionRecord[] }
/**
 * Get wallet secret key
 */
export type GetSecretKey = { 
/**
 * Wallet fingerprint
 */
fingerprint: number }
/**
 * Response with secret key information
 */
export type GetSecretKeyResponse = { 
/**
 * Secret key information if authorized
 */
secrets: SecretKeyInfo | null }
/**
 * Get the count of spendable coins
 */
export type GetSpendableCoinCount = { 
/**
 * Optional asset ID to filter by (null for XCH)
 */
asset_id: string | null }
/**
 * Response with coin count
 */
export type GetSpendableCoinCountResponse = { 
/**
 * Number of spendable coins
 */
count: number }
/**
 * Get the current synchronization status
 */
export type GetSyncStatus = Record<string, never>
/**
 * Response with detailed sync status
 */
export type GetSyncStatusResponse = { 
/**
 * Current wallet balance
 */
balance: Amount; 
/**
 * Unit for balance display
 */
unit: Unit; 
/**
 * Number of coins synced
 */
synced_coins: number; 
/**
 * Total coins to sync
 */
total_coins: number; 
/**
 * Current receive address
 */
receive_address: string; 
/**
 * Burn address for the wallet
 */
burn_address: string; 
/**
 * Unhardened derivation index
 */
unhardened_derivation_index: number; 
/**
 * Hardened derivation index
 */
hardened_derivation_index: number; 
/**
 * Number of NFT files checked
 */
checked_files: number; 
/**
 * Total NFT files to check
 */
total_files: number; 
/**
 * Database size in bytes
 */
database_size: number }
/**
 * Get detailed token information
 */
export type GetToken = { 
/**
 * Asset ID of the token (null for XCH)
 */
asset_id: string | null }
/**
 * Response with token details
 */
export type GetTokenResponse = { 
/**
 * Token information if found
 */
token: TokenRecord | null }
/**
 * Get a specific transaction by height
 */
export type GetTransaction = { 
/**
 * Transaction height/ID
 */
height: number }
/**
 * Response with transaction details
 */
export type GetTransactionResponse = { 
/**
 * Transaction if found
 */
transaction: TransactionRecord | null }
/**
 * List transactions with filtering
 */
export type GetTransactions = { 
/**
 * Starting offset for pagination
 */
offset: number; 
/**
 * Number of transactions to return
 */
limit: number; 
/**
 * Sort in ascending order
 */
ascending: boolean; 
/**
 * Optional search value
 */
find_value: string | null }
/**
 * Response with transactions list
 */
export type GetTransactionsResponse = { 
/**
 * List of transactions
 */
transactions: TransactionRecord[]; 
/**
 * Total number of transactions
 */
total: number }
/**
 * Get a specific theme NFT
 */
export type GetUserTheme = { 
/**
 * NFT ID of the theme
 */
nft_id: string }
export type GetUserThemeResponse = { 
/**
 * Theme data if found
 */
theme: string | null }
/**
 * List all custom theme NFTs
 */
export type GetUserThemes = Record<string, never>
export type GetUserThemesResponse = { 
/**
 * List of theme NFT IDs
 */
themes: string[] }
/**
 * Get the wallet version
 */
export type GetVersion = Record<string, never>
/**
 * Response with version information
 */
export type GetVersionResponse = { 
/**
 * Semantic version string
 */
version: string }
/**
 * Import a wallet key
 */
export type ImportKey = { 
/**
 * Display name for the wallet
 */
name: string; 
/**
 * Mnemonic phrase or private key
 */
key: string; 
/**
 * Starting derivation index
 */
derivation_index?: number; 
/**
 * Optional hardened derivation count
 */
hardened?: boolean | null; 
/**
 * Optional unhardened derivation count
 */
unhardened?: boolean | null; 
/**
 * Whether to save secrets to keychain
 */
save_secrets?: boolean; 
/**
 * Whether to automatically login after import
 */
login?: boolean; 
/**
 * Optional emoji identifier
 */
emoji?: string | null }
/**
 * Response with imported key fingerprint
 */
export type ImportKeyResponse = { 
/**
 * Fingerprint of the imported key
 */
fingerprint: number }
/**
 * Import an offer
 */
export type ImportOffer = { 
/**
 * Offer string to import
 */
offer: string }
/**
 * Response with imported offer ID
 */
export type ImportOfferResponse = { 
/**
 * ID of the imported offer
 */
offer_id: string }
/**
 * Increase the derivation index to generate more addresses
 */
export type IncreaseDerivationIndex = { 
/**
 * Whether to derive hardened addresses (defaults to true if not specified)
 */
hardened?: boolean | null; 
/**
 * Whether to derive unhardened addresses (defaults to true if not specified)
 */
unhardened?: boolean | null; 
/**
 * The target derivation index to increase to
 */
index: number }
/**
 * Response after increasing the derivation index
 */
export type IncreaseDerivationIndexResponse = Record<string, never>
export type InheritedNetwork = "mainnet" | "testnet11"
/**
 * Check if an asset is owned
 */
export type IsAssetOwned = { 
/**
 * Asset ID to check
 */
asset_id: string }
/**
 * Response with asset ownership status
 */
export type IsAssetOwnedResponse = { 
/**
 * Whether the asset is owned by this wallet
 */
owned: boolean }
/**
 * Issue a new CAT token
 */
export type IssueCat = { 
/**
 * Token name
 */
name: string; 
/**
 * Token ticker symbol
 */
ticker: string; 
/**
 * Initial supply amount
 */
amount: Amount; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
export type KeyInfo = { name: string; fingerprint: number; public_key: string; kind: KeyKind; has_secrets: boolean; network_id: string; emoji: string | null }
export type KeyKind = "bls"
/**
 * Lineage proof for CAT coins
 */
export type LineageProof = { 
/**
 * Parent coin name
 */
parentName: string | null; 
/**
 * Inner puzzle hash
 */
innerPuzzleHash: string | null; 
/**
 * Amount
 */
amount: number | null }
export type LogFile = { name: string; text: string }
/**
 * Login to a wallet using a fingerprint
 */
export type Login = { 
/**
 * The unique fingerprint identifier of the wallet to authenticate with. This is a 32-bit unsigned integer that uniquely identifies each wallet key in the system.
 */
fingerprint: number }
/**
 * Response from logging into a wallet
 */
export type LoginResponse = Record<string, never>
/**
 * Log out of the current wallet session
 */
export type Logout = Record<string, never>
/**
 * Response from logging out of a wallet
 */
export type LogoutResponse = Record<string, never>
/**
 * Create a new offer
 */
export type MakeOffer = { 
/**
 * Assets requested in the offer
 */
requested_assets: OfferAmount[]; 
/**
 * Assets offered in exchange
 */
offered_assets: OfferAmount[]; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Optional receive address
 */
receive_address?: string | null; 
/**
 * Optional expiration timestamp
 */
expires_at_second?: number | null; 
/**
 * Whether to automatically import the offer
 */
auto_import?: boolean }
/**
 * Response with created offer
 */
export type MakeOfferResponse = { 
/**
 * Offer string (bech32 encoded)
 */
offer: string; 
/**
 * Offer ID
 */
offer_id: string }
/**
 * Mint a new option
 */
export type MintOption = { 
/**
 * Expiration time in seconds
 */
expiration_seconds: number; 
/**
 * Underlying asset
 */
underlying: OptionAsset; 
/**
 * Strike price asset
 */
strike: OptionAsset; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Response for minting an option
 */
export type MintOptionResponse = { 
/**
 * ID of the minted option
 */
option_id: string; 
/**
 * Transaction summary
 */
summary: TransactionSummary; 
/**
 * Coin spends in the transaction
 */
coin_spends: CoinSpendJson[] }
export type Network = { name: string; ticker: string; prefix?: string | null; precision: number; network_id?: string | null; default_port: number; genesis_challenge: string; agg_sig_me?: string | null; dns_introducers: string[]; peer_introducers: string[]; inherit?: InheritedNetwork | null }
export type NetworkConfig = { default_network: string; target_peers: number; discover_peers: boolean }
export type NetworkKind = "mainnet" | "testnet" | "unknown"
export type NetworkList = { networks: Network[] }
export type NftCollectionRecord = { collection_id: string; did_id: string; metadata_collection_id: string; visible: boolean; name: string | null; icon: string | null }
export type NftData = { blob: string | null; mime_type: string | null; hash_matches: boolean; metadata_json: string | null; metadata_hash_matches: boolean }
/**
 * Individual NFT to mint
 */
export type NftMint = { 
/**
 * Optional target address
 */
address?: string | null; 
/**
 * Edition number
 */
edition_number?: number | null; 
/**
 * Total editions
 */
edition_total?: number | null; 
/**
 * Data hash
 */
data_hash?: string | null; 
/**
 * Data URIs
 */
data_uris?: string[]; 
/**
 * Metadata hash
 */
metadata_hash?: string | null; 
/**
 * Metadata URIs
 */
metadata_uris?: string[]; 
/**
 * License hash
 */
license_hash?: string | null; 
/**
 * License URIs
 */
license_uris?: string[]; 
/**
 * Royalty payment address
 */
royalty_address?: string | null; 
/**
 * Royalty percentage in ten-thousandths (e.g., 300 = 3%)
 */
royalty_ten_thousandths?: number }
export type NftRecord = { launcher_id: string; collection_id: string | null; collection_name: string | null; minter_did: string | null; owner_did: string | null; visible: boolean; sensitive_content: boolean; name: string | null; created_height: number | null; coin_id: string; address: string; royalty_address: string; royalty_ten_thousandths: number; data_uris: string[]; data_hash: string | null; metadata_uris: string[]; metadata_hash: string | null; license_uris: string[]; license_hash: string | null; edition_number: number | null; edition_total: number | null; icon_url: string | null; created_timestamp: number | null; special_use_type: NftSpecialUseType | null }
export type NftRoyalty = { royalty_address: string; royalty_basis_points: number }
export type NftSortMode = "name" | "recent"
export type NftSpecialUseType = "none" | "theme"
/**
 * Type of NFT URI
 */
export type NftUriKind = "data" | "metadata" | "license"
/**
 * Normalize DIDs to latest state
 */
export type NormalizeDids = { 
/**
 * DID IDs to normalize
 */
did_ids: string[]; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Asset amount in an offer
 */
export type OfferAmount = { 
/**
 * Optional asset ID (null for XCH)
 */
asset_id?: string | null; 
/**
 * Optional hidden puzzle hash for privacy
 */
hidden_puzzle_hash?: string | null; 
/**
 * Amount of the asset
 */
amount: Amount }
export type OfferAsset = { asset: Asset; amount: Amount; royalty: Amount; nft_royalty: NftRoyalty | null; option_assets: OptionAssets | null }
export type OfferRecord = { offer_id: string; offer: string; status: OfferRecordStatus; creation_timestamp: number; summary: OfferSummary }
export type OfferRecordStatus = "pending" | "active" | "completed" | "cancelled" | "expired"
export type OfferSummary = { fee: Amount; maker: OfferAsset[]; taker: OfferAsset[]; expiration_height: number | null; expiration_timestamp: number | null }
/**
 * Asset specification for options
 */
export type OptionAsset = { 
/**
 * Asset ID (null for XCH)
 */
asset_id: string | null; 
/**
 * Amount
 */
amount: Amount }
export type OptionAssets = { underlying_asset: Asset; underlying_amount: Amount; strike_asset: Asset; strike_amount: Amount; expiration_seconds: number }
export type OptionRecord = { launcher_id: string; name: string | null; visible: boolean; coin_id: string; address: string; amount: Amount; underlying_asset: Asset; underlying_amount: Amount; underlying_coin_id: string; strike_asset: Asset; strike_amount: Amount; expiration_seconds: number; created_height: number | null; created_timestamp: number | null }
export type OptionSortMode = "name" | "created_height" | "expiration_seconds"
export type PeerRecord = { ip_addr: string; port: number; peak_height: number; user_managed: boolean }
export type PendingTransactionRecord = { transaction_id: string; fee: Amount; submitted_at: number | null }
/**
 * Perform database maintenance operations
 */
export type PerformDatabaseMaintenance = { 
/**
 * Whether to force a full vacuum (may take longer)
 */
force_vacuum: boolean }
/**
 * Response with maintenance operation statistics
 */
export type PerformDatabaseMaintenanceResponse = { 
/**
 * Time spent vacuuming in milliseconds
 */
vacuum_duration_ms: number; 
/**
 * Time spent analyzing in milliseconds
 */
analyze_duration_ms: number; 
/**
 * Time spent checkpointing WAL in milliseconds
 */
wal_checkpoint_duration_ms: number; 
/**
 * Total maintenance duration in milliseconds
 */
total_duration_ms: number; 
/**
 * Number of pages reclaimed by vacuum
 */
pages_vacuumed: number; 
/**
 * Number of WAL pages checkpointed
 */
wal_pages_checkpointed: number }
/**
 * Re-download an `NFT`'s data and metadata from its URIs
 */
export type RedownloadNft = { 
/**
 * The `NFT` ID to re-download
 */
nft_id: string }
/**
 * Response after re-downloading an `NFT`
 */
export type RedownloadNftResponse = Record<string, never>
/**
 * Remove a peer from the connection list
 */
export type RemovePeer = { 
/**
 * IP address or hostname of the peer
 */
ip: string; 
/**
 * Whether to ban the peer from reconnecting
 */
ban: boolean }
/**
 * Rename a wallet key
 */
export type RenameKey = { 
/**
 * Wallet fingerprint
 */
fingerprint: number; 
/**
 * New display name
 */
name: string }
/**
 * Response for key rename
 */
export type RenameKeyResponse = Record<string, never>
/**
 * Resynchronize wallet data with the blockchain
 */
export type Resync = { 
/**
 * The fingerprint of the wallet to resync
 */
fingerprint: number; 
/**
 * Delete all coin records during resync
 */
delete_coins?: boolean; 
/**
 * Delete all asset records during resync
 */
delete_assets?: boolean; 
/**
 * Delete all file records during resync
 */
delete_files?: boolean; 
/**
 * Delete all offer records during resync
 */
delete_offers?: boolean; 
/**
 * Delete all address records during resync
 */
delete_addresses?: boolean; 
/**
 * Delete all block records during resync
 */
delete_blocks?: boolean }
/**
 * Resynchronize a `CAT` token's metadata from an external source
 */
export type ResyncCat = { 
/**
 * The asset ID of the `CAT` token to resynchronize
 */
asset_id: string }
/**
 * Response after resynchronizing a `CAT` token
 */
export type ResyncCatResponse = Record<string, never>
/**
 * Response from resynchronizing the wallet
 */
export type ResyncResponse = Record<string, never>
/**
 * Save a theme NFT to the wallet
 */
export type SaveUserTheme = { 
/**
 * NFT ID of the theme
 */
nft_id: string }
export type SaveUserThemeResponse = Record<string, never>
export type SecretKeyInfo = { mnemonic: string | null; secret_key: string }
/**
 * Send CAT tokens to an address
 */
export type SendCat = { 
/**
 * Asset ID of the CAT
 */
asset_id: string; 
/**
 * Recipient address
 */
address: string; 
/**
 * Amount to send
 */
amount: Amount; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to include the CAT hint
 */
include_hint?: boolean; 
/**
 * Optional memos
 */
memos?: string[]; 
/**
 * Optional clawback timestamp
 */
clawback?: number | null; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Send a transaction immediately
 */
export type SendTransactionImmediately = { 
/**
 * Spend bundle to send
 */
spend_bundle: SpendBundle }
/**
 * Response with transaction status
 */
export type SendTransactionImmediatelyResponse = { 
/**
 * Status code
 */
status: number; 
/**
 * Optional error message
 */
error: string | null }
/**
 * Send XCH to an address
 */
export type SendXch = { 
/**
 * Recipient address
 */
address: string; 
/**
 * Amount to send
 */
amount: Amount; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Optional memos
 */
memos?: string[]; 
/**
 * Optional clawback timestamp (seconds since epoch)
 */
clawback?: number | null; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Set the change address for transactions
 */
export type SetChangeAddress = { 
/**
 * Wallet fingerprint
 */
fingerprint: number; 
/**
 * Change address (null to use default derivation)
 */
change_address: string | null }
/**
 * Enable or disable delta sync
 */
export type SetDeltaSync = { 
/**
 * Whether to enable delta sync
 */
delta_sync: boolean }
/**
 * Override delta sync settings for a specific wallet
 */
export type SetDeltaSyncOverride = { 
/**
 * Wallet fingerprint
 */
fingerprint: number; 
/**
 * Delta sync setting (null to use default)
 */
delta_sync: boolean | null }
/**
 * Enable or disable automatic peer discovery
 */
export type SetDiscoverPeers = { 
/**
 * Whether to enable peer discovery
 */
discover_peers: boolean }
/**
 * Set the active network
 */
export type SetNetwork = { 
/**
 * Network name to switch to
 */
name: string }
/**
 * Override network settings for a specific wallet
 */
export type SetNetworkOverride = { 
/**
 * Wallet fingerprint to override network for
 */
fingerprint: number; 
/**
 * Network name (null to reset to default)
 */
name: string | null }
/**
 * Set target number of peers to maintain
 */
export type SetTargetPeers = { 
/**
 * Target number of peer connections
 */
target_peers: number }
/**
 * Set wallet emoji
 */
export type SetWalletEmoji = { 
/**
 * Wallet fingerprint
 */
fingerprint: number; 
/**
 * Emoji character (null to remove)
 */
emoji: string | null }
/**
 * Response for emoji update
 */
export type SetWalletEmojiResponse = Record<string, never>
/**
 * Sign coin spends to create a transaction
 */
export type SignCoinSpends = { 
/**
 * Coin spends to sign
 */
coin_spends: CoinSpendJson[]; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean; 
/**
 * Whether to partially sign (for multi-signature)
 */
partial?: boolean }
/**
 * Response with signed spend bundle
 */
export type SignCoinSpendsResponse = { 
/**
 * Signed spend bundle
 */
spend_bundle: SpendBundleJson }
/**
 * Sign a message by address
 */
export type SignMessageByAddress = { 
/**
 * Message to sign
 */
message: string; 
/**
 * Address whose key to use
 */
address: string }
/**
 * Response with signed message
 */
export type SignMessageByAddressResponse = { 
/**
 * Public key used
 */
publicKey: string; 
/**
 * Signature
 */
signature: string }
/**
 * Sign a message with a public key
 */
export type SignMessageWithPublicKey = { 
/**
 * Message to sign
 */
message: string; 
/**
 * Public key to use for signing
 */
publicKey: string }
/**
 * Response with message signature
 */
export type SignMessageWithPublicKeyResponse = { 
/**
 * Signature
 */
signature: string }
/**
 * Spend bundle structure
 */
export type SpendBundle = { 
/**
 * Coin spends in the bundle
 */
coin_spends: CoinSpend[]; 
/**
 * Aggregated signature
 */
aggregated_signature: string }
export type SpendBundleJson = { coin_spends: CoinSpendJson[]; aggregated_signature: string }
/**
 * Spendable coin details
 */
export type SpendableCoin = { 
/**
 * Coin information
 */
coin: Coin; 
/**
 * Coin name (ID)
 */
coinName: string; 
/**
 * Puzzle reveal
 */
puzzle: string; 
/**
 * Block height where coin was confirmed
 */
confirmedBlockIndex: number; 
/**
 * Whether the coin is locked
 */
locked: boolean; 
/**
 * Optional lineage proof for CAT coins
 */
lineageProof: LineageProof | null }
/**
 * Split coins into multiple smaller coins
 */
export type Split = { 
/**
 * Coin IDs to split
 */
coin_ids: string[]; 
/**
 * Number of output coins
 */
output_count: number; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Submit a transaction to the network
 */
export type SubmitTransaction = { 
/**
 * Spend bundle to submit
 */
spend_bundle: SpendBundleJson }
/**
 * Response for transaction submission
 */
export type SubmitTransactionResponse = Record<string, never>
export type SyncEvent = { type: "start"; ip: string } | { type: "stop" } | { type: "subscribed" } | { type: "derivation" } | { type: "coin_state" } | { type: "transaction_failed"; transaction_id: string; error: string | null } | { type: "puzzle_batch_synced" } | { type: "cat_info" } | { type: "did_info" } | { type: "nft_data" }
/**
 * Accept an offer
 */
export type TakeOffer = { 
/**
 * Offer string to accept
 */
offer: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Response with accepted offer details
 */
export type TakeOfferResponse = { 
/**
 * Transaction summary
 */
summary: TransactionSummary; 
/**
 * Spend bundle
 */
spend_bundle: SpendBundleJson; 
/**
 * Transaction ID
 */
transaction_id: string }
export type TokenRecord = { asset_id: string | null; name: string | null; ticker: string | null; precision: number; description: string | null; icon_url: string | null; visible: boolean; balance: Amount; revocation_address: string | null }
export type TransactionCoinRecord = { coin_id: string; amount: Amount; address: string | null; address_kind: AddressKind; asset: Asset }
export type TransactionInput = { coin_id: string; amount: Amount; address: string; asset: Asset | null; outputs: TransactionOutput[] }
export type TransactionOutput = { coin_id: string; amount: Amount; address: string; receiving: boolean; burning: boolean }
export type TransactionRecord = { height: number; timestamp: number | null; spent: TransactionCoinRecord[]; created: TransactionCoinRecord[] }
/**
 * Standard transaction response
 */
export type TransactionResponse = { 
/**
 * Transaction summary
 */
summary: TransactionSummary; 
/**
 * Coin spends in the transaction
 */
coin_spends: CoinSpendJson[] }
export type TransactionSummary = { fee: Amount; inputs: TransactionInput[] }
/**
 * Transfer DIDs to a new address
 */
export type TransferDids = { 
/**
 * DID IDs to transfer
 */
did_ids: string[]; 
/**
 * Recipient address
 */
address: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Optional clawback timestamp
 */
clawback?: number | null; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Transfer NFTs to a new owner
 */
export type TransferNfts = { 
/**
 * NFT IDs to transfer
 */
nft_ids: string[]; 
/**
 * Recipient address
 */
address: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Optional clawback timestamp
 */
clawback?: number | null; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
/**
 * Transfer options to another address
 */
export type TransferOptions = { 
/**
 * Option IDs to transfer
 */
option_ids: string[]; 
/**
 * Recipient address
 */
address: string; 
/**
 * Transaction fee
 */
fee: Amount; 
/**
 * Optional clawback timestamp
 */
clawback?: number | null; 
/**
 * Whether to automatically submit the transaction
 */
auto_submit?: boolean }
export type Unit = { ticker: string; precision: number }
/**
 * Update a `CAT` token's metadata and visibility
 */
export type UpdateCat = { 
/**
 * The token record containing updated metadata
 */
record: TokenRecord }
/**
 * Response after updating a `CAT` token
 */
export type UpdateCatResponse = Record<string, never>
/**
 * Update a `DID`'s name and visibility settings
 */
export type UpdateDid = { 
/**
 * The `DID` ID to update
 */
did_id: string; 
/**
 * Optional new name for the `DID`
 */
name: string | null; 
/**
 * Whether the `DID` should be visible in the UI
 */
visible: boolean }
/**
 * Response after updating a `DID`
 */
export type UpdateDidResponse = Record<string, never>
/**
 * Update an `NFT`'s visibility settings
 */
export type UpdateNft = { 
/**
 * The `NFT` ID to update
 */
nft_id: string; 
/**
 * Whether the `NFT` should be visible in the UI
 */
visible: boolean }
/**
 * Update an `NFT` collection's visibility settings
 */
export type UpdateNftCollection = { 
/**
 * The collection ID to update
 */
collection_id: string; 
/**
 * Whether the collection should be visible in the UI
 */
visible: boolean }
/**
 * Response after updating an `NFT` collection
 */
export type UpdateNftCollectionResponse = Record<string, never>
/**
 * Response after updating an `NFT`
 */
export type UpdateNftResponse = Record<string, never>
/**
 * Update an option's visibility settings
 */
export type UpdateOption = { 
/**
 * The option ID to update
 */
option_id: string; 
/**
 * Whether the option should be visible in the UI
 */
visible: boolean }
/**
 * Response after updating an option
 */
export type UpdateOptionResponse = Record<string, never>
/**
 * View coin spends without signing
 */
export type ViewCoinSpends = { 
/**
 * Coin spends to view
 */
coin_spends: CoinSpendJson[] }
/**
 * Response with transaction summary
 */
export type ViewCoinSpendsResponse = { 
/**
 * Transaction summary
 */
summary: TransactionSummary }
/**
 * View an offer without accepting
 */
export type ViewOffer = { 
/**
 * Offer string to view
 */
offer: string }
/**
 * Response with offer details
 */
export type ViewOfferResponse = { 
/**
 * Offer summary
 */
offer: OfferSummary; 
/**
 * Offer status
 */
status: OfferRecordStatus }
export type Wallet = { name: string; fingerprint: number; network?: string | null; delta_sync: boolean | null; emoji?: string | null; change_address?: string | null }
export type WalletDefaults = { delta_sync: boolean }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
